# 1. Асимптотическая сложность

## Общая информация

**Асимптотическая сложность** является частным способом описания алгоритмической сложности - меры эффективности алгоритма, которая описывает, как количество операций или потребление памяти растёт с увеличением размера входных данных (обозначаемого как **n**). Позволяет прогнозировать производительность алгоритма на больших объёмах данных и сравнивать подходы к решению задач.

**Временная сложность (Time Complexity)** измеряет количество операций (шагов), которые выполняет алгоритм, в зависимости от размера входных данных. Используется для того, чтобы оценить как быстро время работы алгоритма растет при увеличении объема данных.

**Пространственная сложность (Space Complexity)** измеряет объем дополнительной памяти, которая используется алгоритмом, в зависимости от размера входных данных, без учёта памяти под сами входные данные. Пространственная сложность оценивает, сколько памяти потребуется алгоритму при увеличении объема данных.

Для сравнения эффективности алгоритмов и оценки их поведения на больших данных используется **O-нотация (Big O Notation)**, которая представляет собой математическую запись для описания верхней границы сложности алгоритма.

Ключевые классы сложности приведены в таблице ниже:

| Запись         | Сложность               | Рост при **n=1000**   |
| -------------- | ----------------------- | --------------------- |
| **O(1)**       | Константная             | 1 операция            |
| **O(log n)**   | Логарифмическая         | ~10 операций          |
| **O(n)**       | Линейная                | 1000 операций         |
| **O(n log n)** | Линейно-логарифмическая | ~10 000 операций      |
| **O(n²)**      | Квадратичная            | 1 000 000 операций    |
| **O(n³)**      | Кубическая              | 1 млрд операций       |
| **O(2ⁿ)**      | Экспоненциальная        | Астрономическое число |
| **O(n!)**      | Факториальная           | 4×10²⁵⁶⁷ операций     |

Основные классы сложности отображены на графике ниже:
![](assets/big-o_01.png)

Асимптотическая сложность и нотация Big O критически важны для анализа алгоритмов по следующим ключевым причинам:

**1. Прогнозирование масштабируемости**

Big O позволяет оценить, как поведёт себя алгоритм при увеличении объёма данных (**n**):

- **O(1)**: Производительность не изменится даже при росте **n** в 1000 раз.

- **O(n)**: Время выполнения вырастет линейно (для **n=10⁶** потребуется в 1000 раз больше операций, чем для **n=10³**).

- **O(2ⁿ)**: Уже при **n=100** вычисления становятся невозможными на практике.

**2. Сравнение алгоритмов**

Big O даёт универсальный язык для объективного сравнения эффективности решений:

```Python
# O(n²) vs O(n log n) для n=1000
bubble_sort()    # ~1 000 000 операций
merge_sort()     # ~10 000 операций (в 100 раз быстрее!)
```

Константы и аппаратные различия игнорируются - весь фокус на _росте_ сложности.

**3. Оптимизация ресурсов**

- **Время**: алгоритм с O(n³) для матриц 100×100 выполнит 1 000 000 операций, а O(n²·³) — ~400 000.

- **Память**: рекурсия O(n) может исчерпать стек при больших **n**, тогда как итерация O(1) по памяти безопасна.

**4. Проектирование систем**

- **Базы данных**: мндексы снижают поиск с O(n) до O(log n), что ускоряет запросы в 1000 раз при **n=10⁶**.

- **Машинное обучение**: экспоненциальная сложность O(2ⁿ) делает полный перебор нереализуемым для больших данных, требуя эвристик.

**5. Анализ предельных случаев**

Big O акцентирует худший сценарий, что критично для:

- **Безопасных систем** (авионика, медицина);

- **Реалтайм-обработки** (трейдинг, стриминг).

**Пример**: Сжатие видео 4K.
Алгоритм с O(n²) займёт часы, а O(n log n) — минуты.

## Как анализировать код

Как определить асимптотическую сложность алгоритма:

1. **Определите параметры, влияющие на время выполнения**
   Установите, от каких переменных (чаще всего это размер входных данных - **n**) зависит количество операций в вашем алгоритме.

2. **Выделите базовые операции**
   Определите, какие операции (сравнения, присваивания, циклы, рекурсивные вызовы) выполняются внутри алгоритма и зависят от размера входных данных.

3. **Подсчитайте количество операций**
   Выразите количество операций как функцию от размера входных данных (n). Например:

- Один цикл по всем элементам: **O(n)**.

- Два вложенных цикла по всем элементам: **O(n²)**.

4. **Отбросьте константы и несущественные слагаемые**
   В полученной функции оставьте только самый быстрорастущий член и игнорируйте константы.
   Например, 3n²+5n+10 преобразуется в **O(n²)**.

5. **Определите асимптотическую сложность**
   Используйте нотацию Big O для записи итоговой оценки сложности (например, **O(n)**, **O(n²)**, **O(log n)**).

**Пример:**
Алгоритм с двумя вложенными циклами по всем элементам массива (n) будет иметь сложность **O(n²)**, так как количество операций растёт как квадрат размера входных данных.
Если в алгоритме есть только один цикл, сложность будет линейной - **O(n)**.

## Примеры

### O(1) — Константная сложность

```Python
def get_first_element(arr):
    return arr[0]  # Одно действие, независимо от размера arr
```

### O(log n) — Логарифмическая сложность

```Python
def binary_search(arr, target):
    low, high = 0, len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1  # Область поиска делится пополам на каждом шаге
    return -1
```

### O(n) — Линейная сложность

```Python
def find_sum(arr):
    total = 0
    for num in arr:  # Проход по всем элементам
        total += num
    return total
```

### **O(n log n) — Линейно-логарифмическая сложность**

```Python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])  # Рекурсия: O(log n) уровней
    right = merge_sort(arr[mid:])
    return merge(left, right)  # Слияние: O(n) на уровень

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```

### **O(n²) — Квадратичная сложность**

```Python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):  # n итераций
        for j in range(0, n - i - 1):  # До n итераций
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
```

### **O(**n³**) —** Кубическая **сложность**

```Python
# Классический пример: перебор всех троек элементов массива для поиска суммы, равной заданному числу.
def has_triplet_sum(arr, S):
    n = len(arr)
    for i in range(n):
        for j in range(i + 1, n):
            for k in range(j + 1, n):
                if arr[i] + arr[j] + arr[k] == S:
                    return True
    return False
```

### **O(2ⁿ) — Экспоненциальная сложность**

```Python
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)  # Два рекурсивных вызова
```

### **O(n!) — Факториальная сложность**

```Python
import itertools
def generate_permutations(data):
    return list(itertools.permutations(data))  # Число перестановок: n!
```
